use Modern::Perl;
use Data::Dumper;
$Data::Dumper::Sortkeys=1;
$Data::Dumper::Indent=1;
use lib 'lib';
use CDD::Card;


our @ranks = qw/3 4 5 6 7 8 9 10 J Q K A 2/;
our @suits = qw/D C H S/;

# each possible group for a given play type (singles, pairs, triples, fivers) has
# a value in the game. A given value may be assigned to many groups
our $VALUE = 0;
our $GROUPID=1;

# what we generated
our $VALUES = { single => {},
                pair   => {},
                triple => {},
                straight => {},
                flush => {},
                fullhouse => {},
                quad => {},
                straightflush => {},
              };
our $PLAYS = {};

our @singles          = ();
our @pairs            = ();
our @triples          = ();
our @straights        = ();
our @flushes          = ();
our @full_houses      = ();
our @quads            = ();
our @straight_flushes = ();

sub key {
    return '[' . join(',', sort {$CDD::Card::CARD_VAL{$a} <=> $CDD::Card::CARD_VAL{$b}} @{+shift}) . ']';
}

sub add_group_val {
    my ($type, $group, $val) = @_;
    die "unknown type: $type" unless exists $VALUES->{$type};
    die "group must be an array of card strings" if ref($group) ne 'ARRAY' and ref($group->[0]) ne '';
    die "must supply val" unless $val;
    $VALUES->{$type}{key($group)} = $val;
}

main();
exit 0;

sub main {
    # singles have their own values
    $VALUE = 1;
    gen_singles();

    # pairs have their own values
    $VALUE = 1;
    gen_pairs();

    # triples have their own values
    $VALUE = 1;
    gen_triples();

    # fivers have their own values, shared amongst straights, flushes,
    # full houses, quads, and straight flushes
    $VALUE = 1;
    gen_straights();
    gen_flushes();
    gen_full_houses();
    gen_quads();
    gen_straight_flushes();

    my $filename = "lib/CDD/Val.pm";    
    open(my $fh, '>', $filename) or die "Couldn't open $filename : $!"; 
    print $fh "package CDD::Val;\nuse Modern::Perl;\n\# This file was generated by util/rank_all_plays.pl.\n";
    foreach my $type (keys %{$VALUES}) {
        print $fh "our " . Data::Dumper->Dump([$VALUES->{$type}], [uc("${type}_val")]) . "\n";
    }
    print $fh "\n1;\n";
    close($fh);
    print "\nGenerated data into $filename!\n";

}

sub gen_singles {
    my $type      = "single";
    my $numcards  = 1;
    my $grouptype = 1;
    for my $r (@ranks) {
        for my $s (@suits) {
            my $c = "$r$s";
            my $cards = [$c];
            push @singles, $cards; 
            add_group_val('single', $cards, $VALUE); 
            print "$type: $c val:$VALUE, group: $GROUPID\n";
            $VALUE++;
            $GROUPID++;
        }
    }

}

# populates grp, grpcard tables with pairs
sub gen_pairs {
    my $type      = "pair";
    my $numcards  = 2;
    my $grouptype = 2;

    my $valsuits = {
        0 => [[qw/D C/],],                         # club high
        1 => [[qw/D H/], [qw/C H/]],               # heart high
        2 => [[qw/D S/], [qw/C S/], [qw/H S/]],    #spade high
    };
    my $newval = 0;
    for my $r (@ranks) {
        foreach my $val (sort keys %{$valsuits}) {
            $newval = $val;
            for my $group (@{$valsuits->{$newval}}) {
                my $printval = $VALUE + $newval;
                my ($s1, $s2) = @{$group};
                my ($c1, $c2) = ("$r$s1", "$r$s2");
                my $cards = [$c1, $c2];
                push @pairs, $cards;
                add_group_val('pair', $cards, $printval);
                print "$type: $c1,$c2 val:$printval, group:$GROUPID\n";
                $GROUPID++;
            }
        }
        $VALUE = $VALUE + $newval + 1;
    }
}

# populates grp, grpcard tables with triples
sub gen_triples {
    my $type      = "triple";
    my $numcards  = 3;
    my $grouptype = 3;

    my $valsuits = {0 => [[qw/D C H/], [qw/D C S/], [qw/D H S/], [qw/C H S/]],};
    my $newval = 0;
    for my $r (@ranks) {
        for my $val (sort keys %{$valsuits}) {
            $newval = $val;
            for my $group (@{$valsuits->{$newval}}) {
                my $printval = $VALUE + $newval;
                my ($s1, $s2, $s3) = @{$group};
                my ($c1, $c2, $c3) = ("$r$s1", "$r$s2", "$r$s3");
                my $cards = [$c1, $c2, $c3];
                push @triples, $cards;
                add_group_val('triple', $cards, $printval);
                print "$type: $c1,$c2,$c3 val:$printval, group:$GROUPID\n";
                $GROUPID++;
            }
        }
        $VALUE = $VALUE + $newval + 1;
    }
}

# populates grp, grpcard tables with straights
sub gen_straights {
    my $type      = "straight";
    my $numcards  = 5;
    my $grouptype = 4;

    for (my $i = 4 ; $i < 13 ; $i++) {    # highcard rank index:  5's up to 2's
        for my $s5 (@suits) {             # 5th in group, highest ranking card's suit
            for my $s4 (@suits) {
                for my $s3 (@suits) {
                    for my $s2 (@suits) {
                        for my $s1 (@suits) {    # 1st in group, lowest ranking card's suit
                                                 # ranks in group
                            my $start = $i - 4;
                            my $stop  = $i;
                            my ($r1, $r2, $r3, $r4, $r5) = @ranks[$start .. $stop];

                            my ($c1, $c2, $c3, $c4, $c5) = ("$r1$s1", "$r2$s2", "$r3$s3", "$r4$s4", "$r5$s5");

                            my $cards = [$c1, $c2, $c3, $c4, $c5];
                            # straight flushes...
                            if (($s1 eq $s2) and ($s2 eq $s3) and ($s3 eq $s4) and ($s4 eq $s5)) {
                                push @straight_flushes, $cards;
                                next;
                            }

                            push @straights, $cards;
                            add_group_val('straight', $cards, $VALUE);
                            print "$type: $c1,$c2,$c3,$c4,$c5 val:$VALUE, group:$GROUPID\n";
                            $GROUPID++;
                        }
                    }
                }
            }

            # value increases when highcard suit changes
            $VALUE++;

        }
    }
    $VALUE--;    # off by one otherwise...
}

# populates grp, grpcard tables with flushes
sub gen_flushes {
    my $type      = "flush";
    my $numcards  = 5;
    my $grouptype = 5;

    my %flush   = ();
    my $valsuit = {
        D => 1,
        C => 9,
        H => 17,
        S => 25,
    };

    my $flushes     = {};
    my $start_value = $VALUE;

    foreach my $s (@suits) {
        for my $ri1 (0 .. 12) {    # lowest rank index
            for my $ri2 (0 .. 12) {
                for my $ri3 (0 .. 12) {
                    for my $ri4 (0 .. 12) {
                        for my $ri5 (0 .. 12) {    # highest rank index
                            my @indices = sort {$a <=> $b} ($ri1, $ri2, $ri3, $ri4, $ri5);
                            my ($i1, $i2, $i3, $i4, $i5) = @indices;
                            if ($i1 == $i2 or $i2 == $i3 or $i3 == $i4 or $i4 == $i5) {
                                next;              # impossible combo
                            }
                            if ($i2 == $i1 + 1 and $i3 == $i2 + 1 and $i4 == $i3 + 1 and $i5 == $i4 + 1) {
                                next;              # straight flush
                            }
                            my $key = join("", @indices) . "$s";

                            if (exists $flush{$key}) {
                                next;
                            }
                            else {
                                $flush{$key}++;
                                my ($r1, $r2, $r3, $r4, $r5) = @ranks[@indices];

                                # there are only 32 cdd values, based on the highest card in a group of each
                                # suit. d,c,h,s; 8 to 2 (8 cards) for each of 4 suits (8*4=32)
                                my $val = ($i5 - 5) + $valsuit->{$s};
                                $VALUE = $start_value + $val;

                                my ($c1, $c2, $c3, $c4, $c5) = ("$r1$s", "$r2$s", "$r3$s", "$r4$s", "$r5$s");
                                my $cards = [$c1, $c2, $c3, $c4, $c5];
                                push @{$flushes->{$val}}, $cards;
                                add_group_val('flush', $cards, $VALUE);
                                print "$type: $c1,$c2,$c3,$c4,$c5 val:$VALUE, group:$GROUPID\n";
                                $GROUPID++;
                            }    #else
                        }    #ri1
                    }    #ri2
                }    #ri3
            }    # ri4
        }    #ri5
    }    # suits
    for my $v (1 .. 32) {
        foreach my $group (@{$flushes->{$v}}) {
            push @flushes, $group;
        }
    }
}

# populates grp, grpcard tables with full houses
sub gen_full_houses {
    my $type      = "full house";
    my $numcards  = 5;
    my $grouptype = 6;

    my $x = 0;
    foreach my $triple (@triples) {
        my ($t1, $t2, $t3) = @{$triple};
        foreach my $pair (@pairs) {
            my ($p1, $p2) = @{$pair};
            my ($tr, $ts, $t_extra) = split //, $t1;
            my ($pr, $ps, $p_extra) = split //, $p1;

            #10 is special case since it has 3 chars...not a 2 char rank/suit
            if ($tr eq '1' and $ts eq '0') {
                $tr = 10;
                $ts = $t_extra;
            }
            if ($pr eq '1' and $ps eq '0') {
                $pr = 10;
                $ps = $p_extra;
            }

            next if $pr eq $tr;
            if ($x ne $tr) {
                $VALUE++;    # value increases as triple changes, low to high
                $x = $tr;
            }
            my ($c1, $c2, $c3, $c4, $c5) = ($t1, $t2, $t3, $p1, $p2);
            my $cards = [$c1, $c2, $c3, $c4, $c5];
            push @full_houses, $cards;
            add_group_val('fullhouse', $cards, $VALUE);
            print "$type: $c1,$c2,$c3,$c4,$c5 val:$VALUE, group:$GROUPID\n";
            $GROUPID++;
        }
    }

}

# populates grp, grpcard tables with quads
sub gen_quads {
    my $type      = "quad";
    my $numcards  = 5;
    my $grouptype = 7;

    my $x = 0;
    foreach my $r (@ranks) {
        foreach my $sa (@singles) {
            my $s = $sa->[0];
            my ($sr, $ss, $s_extra) = split //, $s;

            #10 is special case since it has 3 chars...not a 2 char rank/suit
            if ($sr eq '1' and $ss eq '0') {
                $sr = 10;
                $ss = $s_extra;
            }

            next if ($sr eq $r);

            my ($c1, $c2, $c3, $c4, $c5) = ("${r}D", "${r}C", "${r}H", "${r}S", $s);
            if ($x ne $r) {
                $VALUE++;    # value goes up as rank changes 3 up to 2
                $x = $r;
            }
            my $cards = [$c1, $c2, $c3, $c4, $c5];
            push @quads, $cards;
            add_group_val('quad', $cards, $VALUE);
            print "$type: $c1,$c2,$c3,$c4,$c5 val:$VALUE, group:$GROUPID\n";
            $GROUPID++;
        }
    }

    $VALUE++;    # off by one otherwise
}

# populates grp, grpcard tables with straight flushes
sub gen_straight_flushes {
    my $type      = "straight flush";
    my $numcards  = 5;
    my $grouptype = 8;

    foreach my $cards (@straight_flushes) {
        my ($c1, $c2, $c3, $c4, $c5) = @{$cards};
        add_group_val('straightflush', $cards, $VALUE);
        print "$type: $c1,$c2,$c3,$c4,$c5 val:$VALUE, group:$GROUPID\n";
        $VALUE++;
        $GROUPID++;
    }
}
